<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>6. Dezember ‚Äì Nikolaus im komplizierten Labyrinth</title>
<style>
  :root{
    --cell: 24px;      /* wird per JS angepasst, aber nie < 12px */
    --gap: 2px;        /* bei kleinen Zellen auf 1px reduziert */
    --cols: 10;        /* wird per JS gesetzt */
    --wall:#0f172a;    /* sehr dunkle W√§nde (Slate-950) */
    --path:#ffffff;    /* helle Wege */
    --forest:#166534;  /* Wald au√üen */
    --house:#ffd54f;   /* Ziel-Hintergrund */
    --grid-outline:#00000033;
    --player-scale: 1.25; /* Nikolaus gr√∂√üer */
    --goal-scale:   1.05; /* Ziel etwas gr√∂√üer */
  }

  /* Hintergrundbild + Overlay f√ºr bessere Lesbarkeit */
  body{
    margin:0; height:100%;
    font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    color:#111; background:#e8f3ea;
    /* wird per JS als background-image gesetzt, wenn URL angegeben ist */
    background-size: cover;
    background-position: center center;
    background-attachment: fixed;
  }
  .bg-overlay{
    position:fixed; inset:0; pointer-events:none;
    background:
      linear-gradient(0deg, rgba(0,0,0,.20), rgba(0,0,0,.20));
    z-index:-1;
  }

  header,footer{padding:12px 10px; text-align:center}
  h1{margin:0 0 6px}
  .sub{opacity:.9}

  .wrap{display:grid; place-items:center; padding:10px; gap:10px}

  .bar{display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap}
  .bar button{
    padding:8px 12px; border-radius:10px; border:1px solid #b8c1cc; background:#fff; font:inherit; cursor:pointer;
  }

  /* Rahmen: sichtbare Outline + Schatten, kann notfalls scrollen */
  .frame{
    padding:8px;
    border-radius:16px;
    background: rgba(255,255,255,.65);
    box-shadow: 0 10px 28px rgba(0,0,0,.18), inset 0 0 0 2px var(--grid-outline);
    max-width: 100vw;
    max-height: calc(100vh - 220px);
    overflow: auto; /* Backup, falls‚Äôs sehr knapp wird */
  }

  .maze{
    display:grid;
    grid-template-columns:repeat(var(--cols), var(--cell));
    grid-auto-rows:var(--cell);
    gap:var(--gap);
    touch-action: pan-x pan-y;
    /* sichtbarer Rand um das gesamte Grid */
    outline: 2px solid var(--grid-outline);
    outline-offset: 6px;
    background: #fafafaAA;
    border-radius: 12px;
  }

  .cell{
    width:var(--cell); height:var(--cell);
    border-radius:4px;
    position:relative;
    display:grid; place-items:center;
    user-select:none; overflow:visible;
    /* d√ºnner Rand pro Zelle, damit man das Raster IMMER erkennt */
    box-shadow: inset 0 0 0 1px rgba(0,0,0,.10);
  }

  .wall{   background:var(--wall); }
  .path{   background:var(--path); }
  .forest{ background:var(--forest); }

  .goal{ background:var(--house); }
  .goal.fallback::after{
    content:"üè†";
    font-size:calc(var(--cell)*0.75);
  }

  .sprite{
    position:absolute; inset:50% auto auto 50%;
    transform:translate(-50%,-50%);
    width:calc(var(--cell) * var(--player-scale));
    height:calc(var(--cell) * var(--player-scale));
    display:grid; place-items:center;
    background-repeat:no-repeat; background-size:contain; background-position:center;
    pointer-events:none;
    text-shadow: 0 1px 2px rgba(0,0,0,.35);
  }
  .sprite.emoji{ font-size:calc(var(--cell) * var(--player-scale)*0.9); }

  .goal-sprite{
    position:absolute; inset:50% auto auto 50%;
    transform:translate(-50%,-50%);
    width:calc(var(--cell) * var(--goal-scale));
    height:calc(var(--cell) * var(--goal-scale));
    background-repeat:no-repeat; background-size:contain; background-position:center;
    pointer-events:none;
  }
  .goal-sprite.emoji{ font-size:calc(var(--cell) * var(--goal-scale)*0.9); }

  .hud{ display:grid; gap:10px; justify-items:center; }
  .legend{
    display:inline-grid; grid-auto-flow:column; gap:10px;
    padding:8px 12px; background:#ffffffdd; border-radius:10px;
    box-shadow: 0 1px 4px rgba(0,0,0,.08);
  }
  .legend .dot{ width:14px;height:14px;border-radius:4px;display:inline-block;margin-right:6px;vertical-align:middle}

  .controls{
    display:grid;
    grid-template-areas:
      ". up ."
      "left center right"
      ". down .";
    gap:8px; touch-action:manipulation;
  }
  .btn{
    grid-area:center; width:56px;height:56px;border-radius:12px;border:1px solid #b8c1cc;background:#fff;font-size:22px;
  }
  .btn:active{ transform:translateY(1px); }
  .up{grid-area:up}.down{grid-area:down}.left{grid-area:left}.right{grid-area:right}

  .win{display:none; padding:10px 14px; background:#fff3cd; border:1px solid #ffe08a; border-radius:10px;}

  @media (max-width: 380px){
    .btn{ width:48px; height:48px; font-size:20px; }
    .frame{ max-height: calc(100vh - 200px); }
  }
</style>
</head>
<body>
<div class="bg-overlay"></div>

<header>
  <h1>6. Dezember ‚Äì Nikolaus im komplizierten Labyrinth</h1>
  <div class="sub">Vom Wald au√üen zum gelben Haus in der Mitte. Viel Spa√ü!</div>
</header>

<main class="wrap">
  <div class="bar">
    <button id="regen">Neu erzeugen</button>
  </div>

  <div class="frame" id="frame">
    <div id="maze" class="maze" aria-label="Labyrinth" role="grid" tabindex="0"></div>
  </div>

  <div class="hud">
    <div class="legend" aria-hidden="true">
      <span><span class="dot" style="background:var(--forest)"></span>Wald</span>
      <span><span class="dot" style="background:var(--path)"></span>Weg</span>
      <span><span class="dot" style="background:var(--wall)"></span>Wand</span>
      <span>Ziel</span>
      <span>üéÖ Du</span>
    </div>

    <div class="controls" id="dpad" aria-label="Steuerkreuz">
      <button class="btn up" aria-label="Nach oben">‚ñ≤</button>
      <button class="btn left" aria-label="Nach links">‚óÄ</button>
      <button class="btn" aria-label="Zentrum" disabled>üéÖ</button>
      <button class="btn right" aria-label="Nach rechts">‚ñ∂</button>
      <button class="btn down" aria-label="Nach unten">‚ñº</button>
    </div>

    <div class="win" id="win">Geschafft! Merke dir den Buchstaben: <strong id="letter">N</strong></div>
  </div>
</main>

<footer><p><a href="index.html">Zur√ºck zum Kalender</a></p></footer>

<script>
/* ==============================
   Deine Bilder
   ============================== */
/* Setz hier einfach URLs. Leer = Emoji/Fallback. */
const backgroundImageURL = ""; // z.B. "assets/ich.jpg"
const playerImageURL     = ""; // z.B. "assets/nikolaus.png"
const goalImageURL       = ""; // z.B. "assets/gelbes-haus.png"

/* Hintergrund anwenden (mit leichter Abdunklung durch .bg-overlay) */
if (backgroundImageURL){
  document.body.style.backgroundImage = `url('${backgroundImageURL}')`;
}

/* ==============================
   Labyrinth: klein & komplex (33√ó33)
   mit hoher Sichtbarkeit und robuster Gr√∂√üenlogik
   ============================== */
const FOREST=2, WALL=1, PATH=0;
const SIZE = 33;                 // innen: gut f√ºr Handy
let GRID = 0;
let grid, position, goal;

const mazeEl   = document.getElementById('maze');
const frameEl  = document.getElementById('frame');
const regenBtn = document.getElementById('regen');

regenBtn.addEventListener('click', generateAndDraw);
window.addEventListener('resize', ()=>fitCellSize(true)); // true = nur Gr√∂√üe neu setzen

generateAndDraw(); // Start

function generateAndDraw(){
  GRID = SIZE + 2; // + √§u√üerer Waldring
  document.documentElement.style.setProperty('--cols', GRID);
  ({grid, position, goal} = buildMazeComplex(SIZE));
  fitCellSize(false); // nach GRID+Maze, damit Werte sicher vorhanden sind
  draw();
  attachControls();
}

/* Sichere Zellgr√∂√üenberechnung:
   - Nie kleiner als 12px
   - Ber√ºcksichtigt Header/HUD/Button-H√∂hen
   - Passt Gap an */
function fitCellSize(onlySize){
  const headerH = document.querySelector('header')?.offsetHeight || 0;
  const hudH    = document.querySelector('.hud')?.offsetHeight    || 0;
  const barH    = document.querySelector('.bar')?.offsetHeight    || 0;

  const vw = Math.max(document.documentElement.clientWidth,  window.innerWidth  || 0);
  const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);

  // verf√ºgbarer Platz f√ºr das Grid
  const availW = Math.max(200, vw - 24);
  const availH = Math.max(200, vh - (headerH + barH + hudH + 24));

  // Schutz, falls GRID noch 0 w√§re
  const cols = Math.max(1, parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cols')) || GRID || 1);

  const cellByW = Math.floor(availW / cols) - 1;
  const cellByH = Math.floor(availH / cols) - 1;

  // NIE zu klein, NIE negativ
  const cell = Math.max(12, Math.min(36, Math.min(cellByW, cellByH)));
  const gap  = cell < 16 ? 1 : 2;

  document.documentElement.style.setProperty('--cell', cell + 'px');
  document.documentElement.style.setProperty('--gap',  gap  + 'px');

  // Rahmenh√∂he setzen (Backup-Scroll, wenn‚Äôs extrem eng wird)
  frameEl.style.maxHeight = Math.max(180, availH) + 'px';

  if (!onlySize && GRID){ draw(); }
}

/* Generator: Turn-Bias + Spurs + wenige Loops ‚Üí viele Sackgassen & Abzweigungen */
function buildMazeComplex(n){
  if (n % 2 === 0) n -= 1;
  const rows=n, cols=n;
  const carve = Array.from({length: rows}, () => Array.from({length: cols}, () => WALL));
  const inBounds = (r,c) => r>0 && c>0 && r<rows-1 && c<cols-1;

  let r = 1, c = Math.floor(cols/2);
  carve[r][c] = PATH;

  const stack = [[r,c]];
  const DIRS = [[-2,0],[2,0],[0,-2],[0,2]];
  let last = -1;

  while (stack.length){
    const [cr,cc] = stack[stack.length-1];
    const cand = [];
    for (let i=0;i<DIRS.length;i++){
      const [dr,dc]=DIRS[i], nr=cr+dr, nc=cc+dc;
      if (inBounds(nr,nc) && carve[nr][nc]===WALL) cand.push({i,nr,nc,mr:dr/2,mc:dc/2});
    }
    if (cand.length){
      cand.sort((a,b)=>{
        const aTurn=(a.i===last)?1:0, bTurn=(b.i===last)?1:0;
        if (aTurn!==bTurn) return aTurn - bTurn; // lieber Kurven
        return Math.random()-0.5;
      });
      const p=cand[0];
      carve[cr+p.mr][cc+p.mc]=PATH;
      carve[p.nr][p.nc]=PATH;
      stack.push([p.nr,p.nc]); last=p.i;
    } else { stack.pop(); last=-1; }
  }

  // Spurs (mehr Sackgassen)
  const spurChance = 0.20;
  for (let rr=1; rr<rows-1; rr++){
    for (let cc=1; cc<cols-1; cc++){
      if (carve[rr][cc]!==PATH || Math.random()>=spurChance) continue;
      const shuffled = DIRS.slice().sort(()=>Math.random()-0.5);
      for (const [dr,dc] of shuffled){
        const a1=rr+dr/2, b1=cc+dc/2;
        const a2=rr+dr,   b2=cc+dc;
        if (inBounds(a2,b2) && carve[a1][b1]===WALL && carve[a2][b2]===WALL){
          carve[a1][b1]=PATH;
          if (Math.random()<0.5 && inBounds(a2,b2)) carve[a2][b2]=PATH;
          break;
        }
      }
    }
  }

  // Wenige Loops (Abzweigungen)
  const loopChance = 0.05;
  for (let rr=2; rr<rows-2; rr++){
    for (let cc=2; cc<cols-2; cc++){
      if (carve[rr][cc]!==WALL || Math.random()>=loopChance) continue;
      const horiz=(carve[rr][cc-1]===PATH && carve[rr][cc+1]===PATH);
      const vert =(carve[rr-1][cc]===PATH && carve[rr+1][cc]===PATH);
      if (horiz || vert) carve[rr][cc]=PATH;
    }
  }

  // Gro√ües Grid mit Waldring
  const big = Array.from({length:n+2},(_,R)=>
    Array.from({length:n+2},(_,C)=>{
      if (R===0||C===0||R===n+1||C===n+1) return FOREST;
      return carve[R-1][C-1]===WALL ? WALL : PATH;
    })
  );

  // Eingang unterhalb Start √∂ffnen, Ziel in der Mitte
  const entranceCol = Math.floor((n+2)/2);
  big[1][entranceCol] = PATH;

  const start = { r: 0, c: entranceCol };
  const g     = { r: Math.floor((n+2)/2), c: Math.floor((n+2)/2) };

  return { grid: big, position: start, goal: g };
}

/* Render */
function draw(){
  mazeEl.innerHTML = '';
  for (let r=0; r<GRID; r++){
    for (let c=0; c<GRID; c++){
      const cell = document.createElement('div');
      const v = grid[r][c];

      if (r===goal.r && c===goal.c){
        cell.className = 'cell goal';
        if (goalImageURL){
          const s = document.createElement('div');
          s.className = 'goal-sprite';
          s.style.backgroundImage = `url('${goalImageURL}')`;
          cell.appendChild(s);
        } else {
          cell.classList.add('fallback');
        }
      } else if (v===WALL) {
        cell.className = 'cell wall';
      } else if (v===FOREST) {
        cell.className = 'cell forest';
      } else {
        cell.className = 'cell path';
      }

      if (r===position.r && c===position.c){
        const s = document.createElement('div');
        if (playerImageURL){
          s.className = 'sprite';
          s.style.backgroundImage = `url('${playerImageURL}')`;
        } else {
          s.className = 'sprite emoji';
          s.textContent = 'üéÖ';
        }
        s.setAttribute('aria-hidden','true');
        cell.classList.add('player');
        cell.tabIndex = 0;
        cell.appendChild(s);
      }

      mazeEl.appendChild(cell);
    }
  }
  focusPlayer();
}

function focusPlayer(){
  const p = mazeEl.querySelector('.player');
  if (p) p.focus({preventScroll:true});
}

/* Bewegung & Win */
function canMove(r,c){ return !(r<0||c<0||r>=GRID||c>=GRID) && grid[r][c]!==WALL; }
function move(dr,dc){
  const nr=position.r+dr, nc=position.c+dc;
  if(!canMove(nr,nc)) return;
  position={r:nr,c:nc};
  draw();
  if(position.r===goal.r && position.c===goal.c){
    document.getElementById('win').style.display='block';
    document.getElementById('letter').textContent='N';
    detachControls();
  }
}

/* Controls */
const upBtn    = document.querySelector('.up');
const downBtn  = document.querySelector('.down');
const leftBtn  = document.querySelector('.left');
const rightBtn = document.querySelector('.right');

function keyHandler(e){
  const k=e.key.toLowerCase();
  if(['arrowup','w'].includes(k)) move(-1,0);
  else if(['arrowdown','s'].includes(k)) move(1,0);
  else if(['arrowleft','a'].includes(k)) move(0,-1);
  else if(['arrowright','d'].includes(k)) move(0,1);
}

let sx=0, sy=0, st=0;
const SWIPE_MIN=22, SWIPE_MAXT=600;
function onTouchStart(e){
  if (!e.touches || e.touches.length!==1) return;
  sx=e.touches[0].clientX; sy=e.touches[0].clientY; st=Date.now();
}
function onTouchEnd(e){
  const dt=Date.now()-st; if(dt>SWIPE_MAXT) return;
  const t=e.changedTouches && e.changedTouches[0]; if(!t) return;
  const dx=t.clientX-sx, dy=t.clientY-sy;
  if (Math.max(Math.abs(dx),Math.abs(dy))<SWIPE_MIN) return;
  if (Math.abs(dx)>Math.abs(dy)) move(0, dx>0?1:-1);
  else move(dy>0?1:-1, 0);
}

function attachControls(){
  detachControls();
  document.addEventListener('keydown', keyHandler);
  mazeEl.addEventListener('touchstart', onTouchStart, {passive:false});
  mazeEl.addEventListener('touchend', onTouchEnd, {passive:false});
  upBtn.onclick    = ()=>move(-1,0);
  downBtn.onclick  = ()=>move(1,0);
  leftBtn.onclick  = ()=>move(0,-1);
  rightBtn.onclick = ()=>move(0,1);
}
function detachControls(){
  document.removeEventListener('keydown', keyHandler);
  mazeEl.removeEventListener('touchstart', onTouchStart, {passive:false});
  mazeEl.removeEventListener('touchend', onTouchEnd, {passive:false});
  upBtn.onclick = downBtn.onclick = leftBtn.onclick = rightBtn.onclick = null;
}
</script>
</body>
</html>




