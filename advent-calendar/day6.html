<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>6. Dezember ‚Äì Nikolaus im harten Labyrinth</title>

<style>
  /* ===============================
     1) Variablen
     =============================== */
  :root{
    /* Spielfeld */
    --cell: 22px;
    --gap: 2px;
    --cols: 10;

    /* Farben */
    --wall:#0f172a;     /* W√§nde */
    --path:#ffffff;     /* besuchte Wege */
    --path-dim:#cbd5e1; /* graue Wege (im Sichtkegel, unbesucht) */
    --forest:#166534;   /* Au√üenwald */
    --house:#ffd54f;    /* Ziel */
    --grid-outline:#00000033;

    /* Sprite-Gr√∂√üen */
    --player-scale: 1.2;
    --goal-scale:   1.05;

    /* Hintergrundbild steuerbar √ºber Variablen */
    --bg-image: none;               /* wird per JS gesetzt: url('...') */
    --bg-size: cover;               /* cover | contain | 1200px 800px | auto */
    --bg-position: center center;   /* z.B.: left top | right bottom | 50% 30% */
    --bg-repeat: no-repeat;         /* no-repeat | repeat | repeat-x | repeat-y */
    --bg-attachment: fixed;         /* fixed (parallax) | scroll */
    --bg-overlay: rgba(0,0,0,.16);  /* Overlay-Farbe/Transparenz */
    --bg-filter: none;              /* z.B.: blur(2px) brightness(.95) */
  }

  /* ===============================
     2) Grundlayout & Hintergrund
     =============================== */
  body{
    margin:0; height:100%;
    font-family:system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    color:#111;

    /* Hintergrundbild aus Variablen */
    background-image: var(--bg-image);
    background-size: var(--bg-size);
    background-position: var(--bg-position);
    background-repeat: var(--bg-repeat);
    background-attachment: var(--bg-attachment);

    /* optionaler Filter aufs gesamte Body (inkl. Bild) */
    filter: var(--bg-filter);
  }
  .bg-overlay{
    position:fixed; inset:0; pointer-events:none;
    background: var(--bg-overlay);
    z-index:-1;
  }

  /* ===============================
     3) Typografie / Rahmen
     =============================== */
  header, footer { padding:10px 8px; text-align:center; }
  h1{ margin:0 0 6px; font-size:1.1rem; }
  .sub{ opacity:.9; font-size:.95rem; }
  .intro{
    margin:8px auto 0; max-width:800px; padding:8px 10px;
    background:#fff; border:1px solid #dbe2ea; border-radius:10px; line-height:1.35;
  }

  /* ===============================
     4) Layout Container
     =============================== */
  .wrap{ display:grid; place-items:center; padding:8px; gap:8px; }
  .bar{ display:flex; gap:8px; align-items:center; justify-content:center; flex-wrap:wrap; }
  .bar button{
    padding:8px 12px; border-radius:10px; border:1px solid #b8c1cc; background:#fff; font:inherit; cursor:pointer;
  }
  .frame{
    padding:6px; border-radius:14px; background:rgba(255,255,255,.65);
    box-shadow:0 10px 28px rgba(0,0,0,.18), inset 0 0 0 2px var(--grid-outline);
    max-width:100vw; max-height:calc(100vh - 220px); overflow:auto;
  }

  /* ===============================
     5) Maze Grid & Zellen
     =============================== */
  .maze{
    display:grid;
    grid-template-columns:repeat(var(--cols), var(--cell));
    grid-auto-rows:var(--cell);
    gap:var(--gap);
    touch-action: pan-y;
    outline:2px solid var(--grid-outline);
    outline-offset:4px;
    background:#fafafaAA; border-radius:10px;
    isolation:isolate;
  }
  .cell{
    width:var(--cell); height:var(--cell);
    border-radius:4px; position:relative; display:grid; place-items:center;
    user-select:none; overflow:visible;
    box-shadow: inset 0 0 0 1px rgba(0,0,0,.10);
  }
  .wall{   background:var(--wall); }
  .path{   background:var(--path); }
  .path.dim{ background:var(--path-dim); }
  .forest{ background:var(--forest); }

  .goal{ background:var(--house); }
  .goal.fallback::after{ content:"üè†"; font-size:calc(var(--cell)*0.75); }
  .goal.dim{ filter:brightness(.85); }

  /* ===============================
     6) Sprites
     =============================== */
  .sprite{
    position:absolute; inset:50% auto auto 50%; transform:translate(-50%,-50%);
    width:calc(var(--cell) * var(--player-scale)); height:calc(var(--cell) * var(--player-scale));
    display:grid; place-items:center; background-repeat:no-repeat; background-size:contain; background-position:center;
    pointer-events:none; text-shadow:0 1px 2px rgba(0,0,0,.35);
  }
  .sprite.emoji{ font-size:calc(var(--cell) * var(--player-scale)*0.9); }
  .goal-sprite{
    position:absolute; inset:50% auto auto 50%; transform:translate(-50%,-50%);
    width:calc(var(--cell) * var(--goal-scale)); height:calc(var(--cell) * var(--goal-scale));
    background-repeat:no-repeat; background-size:contain; background-position:center; pointer-events:none;
  }

  /* ===============================
     7) Fog of War
     =============================== */
  .fog{
    background:#0b1220 !important;
    box-shadow:none !important;
  }
  .fog::after{ display:none; }
  .fog > * { display:none !important; }

  /* ===============================
     8) Hinweise & Controls
     =============================== */
  .hint{ font-size:.9rem; opacity:.9; margin:2px 0 0; text-align:center; }
  .controls{
    display:grid;
    grid-template-areas:
      ". up ."
      "left center right"
      ". down .";
    gap:8px; touch-action:none;
  }
  .btn{ grid-area:center; width:52px;height:52px;border-radius:12px;border:1px solid #b8c1cc;background:#fff;font-size:20px; }
  .btn:active{ transform:translateY(1px); }
  .up{grid-area:up}.down{grid-area:down}.left{grid-area:left}.right{grid-area:right}

  /* ===============================
     9) Responsive
     =============================== */
  @media (max-width:400px){
    .frame{ max-height: calc(100vh - 200px); }
    .btn{ width:46px; height:46px; font-size:18px; }
  }
</style>
</head>

<body>
  <div class="bg-overlay"></div>

  <header>
    <h1>6. Dezember ‚Äì Nikolaus im harten Labyrinth</h1>
    <div class="sub">Langer Umweg ums Haus, viele Sackgassen. Au√üenwald bleibt sichtbar.</div>
    <p class="intro">‚ÄûVon drau√üen vom Walde, da komme ich her, aber ich habe leider den Weg zur Eichb√ºhlstra√üe vergessen. Kannst du mir zeigen, wie ich zu deinem Haus komme?‚Äú</p>
  </header>

  <main class="wrap">
    <div class="bar"><button id="regen">Neu erzeugen</button></div>

    <div class="frame" id="frame">
      <div id="maze" class="maze" aria-label="Labyrinth" role="grid" tabindex="0"></div>
    </div>

    <p class="hint">Falls es zu schwer ist, dann ist hier eine Taschenlampe:</p>
    <div class="bar"><button id="fogToggle" class="toggle" aria-pressed="false">Sichtfeld AN</button></div>

    <div class="controls" aria-label="Pfeiltasten">
      <button class="btn up"    aria-label="Nach oben">‚ñ≤</button>
      <button class="btn left"  aria-label="Nach links">‚óÄ</button>
      <button class="btn"       aria-label="Zentrum" disabled>üéÖ</button>
      <button class="btn right" aria-label="Nach rechts">‚ñ∂</button>
      <button class="btn down"  aria-label="Nach unten">‚ñº</button>
    </div>

    <div class="win" id="win" style="display:none">Geschafft! Merke dir den Buchstaben: <strong id="letter">N</strong></div>
  </main>

  <footer><p><a href="index.html">Zur√ºck zum Kalender</a></p></footer>

<script>
/* =========================================================
   A) Hintergrundbild ‚Äì zentrale Konfiguration
   =========================================================
   -> Hier stellst du alles zum Hintergrundbild ein.
   Erkl√§rungen:
   - url: Pfad zum Bild (leer lassen f√ºr kein Bild)
   - size: "cover" (f√ºllt, kann schneiden) | "contain" (komplett sichtbar)
           oder feste Ma√üe z.B. "1200px 800px"
   - position: "center center" | "left top" | "right 20%" | "50% 30%"
   - repeat: "no-repeat" | "repeat" | "repeat-x" | "repeat-y"
   - attachment: "fixed" (Parallax) | "scroll" (scrollt mit)
   - overlay: RGBA-Farbe/Transparenz √ºber dem Bild
   - filter: CSS-Filter (z.B. "blur(1px) brightness(.95)")
*/
const BG = {
  url: "assets/nikolaus_map.png",
  size: "cover",
  position: "center center",
  repeat: "no-repeat",
  attachment: "fixed",
  overlay: "rgba(0,0,0,.16)",
  filter: "none",
};

/* Wende die BG-Konfiguration auf CSS-Variablen an */
(function applyBackgroundConfig(){
  const root = document.documentElement;
  if (BG.url) {
    const safeURL = encodeURI(BG.url);
    root.style.setProperty('--bg-image', `url('${safeURL}')`);
  } else {
    root.style.setProperty('--bg-image', 'none');
  }
  root.style.setProperty('--bg-size', BG.size);
  root.style.setProperty('--bg-position', BG.position);
  root.style.setProperty('--bg-repeat', BG.repeat);
  root.style.setProperty('--bg-attachment', BG.attachment);
  root.style.setProperty('--bg-overlay', BG.overlay);
  root.style.setProperty('--bg-filter', BG.filter);
})();

/* =========================================================
   B) Spiel-Assets (optional)
   ========================================================= */
const playerImageURL = ""; // z.B. "assets/nikolaus.png"
const goalImageURL   = ""; // z.B. "assets/gelbes-haus.png"

/* =========================================================
   C) Level-Einstellungen
   ========================================================= */
const USE_LEVEL = true; // <-- nutzt das feste LEVEL unten

/* DEIN 29√ó29-Level: 0 = Weg, 1 = Wand
   (ich habe nur eine doppelte Schlusszeile entfernt, damit es exakt 29√ó29 bleibt) */
const LEVEL = [
 [1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
 [1,0,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1],
 [1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1],
 [1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1],
 [1,0,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1],
 [1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1],
 [1,0,1,0,1,1,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1],
 [1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,1],
 [1,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1],
 [1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,1,0,1,1,1,1,0,0,0,0,1,0,1,1],
 [1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,1,0,1,0,1,1],
 [1,1,0,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,1,1],
 [1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,1,1],
 [1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1],
 [1,1,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1],
 [1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,1],
 [1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,1,1,0,1,1,0,1,1],
 [1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,1],
 [1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1],
 [1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1],
 [1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1],
 [1,1,0,1,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,1,1,1,1],
 [1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,1,1,1,1],
 [1,1,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,1,1,1,1],
 [1,1,0,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,0,0,1,1],
 [1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1],
 [1,1,0,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,1],
 [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

/* =========================================================
   D) Engine / Logik
   ========================================================= */
const FOREST=2, WALL=1, PATH=0;
const SIZE = 29;   // fix
let GRID = 0;
let grid, position, goal;

/* Taschenlampe */
let lampOn = false;
const FOG_RADIUS = 2;
let visited;

/* DOM */
const mazeEl   = document.getElementById('maze');
const frameEl  = document.getElementById('frame');
const regenBtn = document.getElementById('regen');
const fogBtn   = document.getElementById('fogToggle');
const upBtn    = document.querySelector('.up');
const downBtn  = document.querySelector('.down');
const leftBtn  = document.querySelector('.left');
const rightBtn = document.querySelector('.right');

/* Events */
regenBtn.addEventListener('click', generateAndDraw);
fogBtn.addEventListener('click', () => {
  lampOn = !lampOn;
  fogBtn.textContent = lampOn ? 'Sichtfeld AUS' : 'Sichtfeld AN';
  fogBtn.setAttribute('aria-pressed', String(lampOn));
  draw();
});
window.addEventListener('resize', ()=>fitCellSize(true));

/* Init */
generateAndDraw();

/* ==== Pipeline ==== */
function generateAndDraw(){
  GRID = SIZE + 2; // + √§u√üerer Wald-Ring
  document.documentElement.style.setProperty('--cols', String(GRID));

  let carve;
  if (USE_LEVEL && isValidLevel(LEVEL)) {
    carve = copyLevel(LEVEL);
  } else {
    carve = buildMazeComplex(SIZE); // Fallback-Generator
  }

  const mid = { r: Math.floor(SIZE/2), c: Math.floor(SIZE/2) };

  // Eingang: w√§hle eine 0 in Zeile 1 (Index 1), die am weitesten von der Mitte entfernt ist
  const bestEntranceColInner = pickEntranceFromTopRow(carve, mid.c);

  // Gro√ües Grid + Start/Ziel
  const entranceColBig = bestEntranceColInner + 1;
  ({grid, position, goal} = buildBigGrid(carve, entranceColBig, mid));

  // Sichtbarkeit
  visited = new Set();
  visited.add(`${position.r},${position.c}`);

  fitCellSize(true);
  draw();
  attachControls();
}

/* ==== Level-Helfer ==== */
function isValidLevel(arr){
  if (!Array.isArray(arr) || arr.length !== SIZE) return false;
  for (const row of arr){
    if (!Array.isArray(row) || row.length !== SIZE) return false;
    for (const v of row){ if (!(v===0 || v===1)) return false; }
  }
  return true;
}
function copyLevel(arr){ return arr.map(row => row.slice()); }
function pickEntranceFromTopRow(carve, centerC){
  const candidates = [];
  for (let c=0;c<SIZE;c++){
    if (carve[1][c]===PATH) candidates.push(c);
  }
  if (!candidates.length){
    const c = Math.floor(SIZE/2);
    carve[1][c]=PATH; return c;
  }
  let best=candidates[0], bestD=-1;
  for (const c of candidates){
    const d=Math.abs(c-centerC);
    if (d>bestD){ bestD=d; best=c; }
  }
  return best;
}

/* ==== Generator (Fallback) ==== */
function buildMazeComplex(n){
  if (n % 2 === 0) n -= 1;
  const rows=n, cols=n;
  const carve = Array.from({length: rows}, () => Array.from({length: cols}, () => WALL));
  const inBounds = (r,c) => r>0 && c>0 && r<rows-1 && c<cols-1;

  let r = 1, c = Math.floor(cols/2);
  carve[r][c] = PATH;

  const stack = [[r,c]];
  const DIRS = [[-2,0],[2,0],[0,-2],[0,2]];
  let last = -1;

  while (stack.length){
    const [cr,cc] = stack[stack.length-1];
    const cand = [];
    for (let i=0;i<DIRS.length;i++){
      const [dr,dc]=DIRS[i], nr=cr+dr, nc=cc+dc;
      if (inBounds(nr,nc) && carve[nr][nc]===WALL) cand.push({i,nr,nc,mr:dr/2,mc:dc/2});
    }
    if (cand.length){
      cand.sort((a,b)=>{
        const aTurn=(a.i===last)?1:0, bTurn=(b.i===last)?1:0;
        if (aTurn!==bTurn) return aTurn - bTurn;
        return Math.random()-0.5;
      });
      const p=cand[0];
      carve[cr+p.mr][cc+p.mc]=PATH;
      carve[p.nr][p.nc]=PATH;
      stack.push([p.nr,p.nc]); last=p.i;
    } else { stack.pop(); last=-1; }
  }

  // Extra-G√§nge
  const spurChance = 0.42;
  for (let rr=1; rr<rows-1; rr++){
    for (let cc=1; cc<cols-1; cc++){
      if (carve[rr][cc]!==PATH || Math.random()>=spurChance) continue;
      const dirs = [[-2,0],[2,0],[0,-2],[0,2]].sort(()=>Math.random()-0.5);
      for (const [dr,dc] of dirs){
        const a1=rr+dr/2, b1=cc+dc/2;
        const a2=rr+dr,   b2=cc+dc;
        if (!(a1>0&&b1>0&&a1<rows-1&&b1<cols-1)) continue;
        if (!(a2>0&&b2>0&&a2<rows-1&&b2<cols-1)) continue;
        if (carve[a1][b1]===WALL && carve[a2][b2]===WALL){
          carve[a1][b1]=PATH;
          if (Math.random()<0.85){ carve[a2][b2]=PATH;
            const a3=a2+dr/2, b3=b2+dc/2;
            if (Math.random()<0.35 && a3>0&&b3>0&&a3<rows-1&&b3<cols-1 && carve[a3][b3]===WALL){ carve[a3][b3]=PATH; }
          }
          break;
        }
      }
    }
  }
  return carve;
}

/* ==== Big grid mit Wald-Ring + Eingang + Start/Ziel ==== */
function buildBigGrid(carve, entranceColBig, mid){
  const n=carve.length;
  const big = Array.from({length:n+2},(_,R)=>
    Array.from({length:n+2},(_,C)=>{
      if (R===0||C===0||R===n+1||C===n+1) return FOREST;
      return carve[R-1][C-1];
    })
  );
  // Eingang oben √∂ffnen
  big[1][entranceColBig]=PATH;

  const start = { r: 0, c: entranceColBig };
  const g     = { r: mid.r+1, c: mid.c+1 }; // +1 wegen Wald-Ring
  return { grid: big, position:start, goal:g };
}

/* ==== Sizing ==== */
function fitCellSize(onlySize){
  const headerH = document.querySelector('header')?.offsetHeight || 0;
  const bars = [...document.querySelectorAll('.bar')].reduce((h,el)=>h+el.offsetHeight,0);
  const controlsH = document.querySelector('.controls')?.offsetHeight || 0;
  const winH    = document.getElementById('win')?.offsetHeight    || 0;

  const vw = Math.max(document.documentElement.clientWidth,  window.innerWidth  || 0);
  const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);

  const availW = Math.max(200, vw - 20);
  const availH = Math.max(200, vh - (headerH + bars + controlsH + winH + 20));

  const cols = GRID || parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cols')) || 1;
  const cellByW = Math.floor(availW / cols) - 1;
  const cellByH = Math.floor(availH / cols) - 1;

  const cell = Math.max(10, Math.min(22, Math.min(cellByW, cellByH)));
  const gap  = cell < 16 ? 1 : 2;

  document.documentElement.style.setProperty('--cell', cell + 'px');
  document.documentElement.style.setProperty('--gap',  gap  + 'px');
  frameEl.style.maxHeight = Math.max(160, availH) + 'px';

  if (!onlySize && GRID){ draw(); }
}

/* ==== Render ==== */
function draw(){
  const { seenEver, fringeNow } = computeVisibilityStates();
  mazeEl.innerHTML = '';
  for (let r=0; r<GRID; r++){
    for (let c=0; c<GRID; c++){
      const cell = document.createElement('div');
      const v = grid[r][c];

      // Grundtyp
      if (r===goal.r && c===goal.c){
        cell.className = 'cell goal';
        if (goalImageURL){
          const s = document.createElement('div');
          s.className = 'goal-sprite';
          s.style.backgroundImage = `url('${goalImageURL}')`;
          cell.appendChild(s);
        } else { cell.classList.add('fallback'); }
      } else if (v===WALL) { cell.className = 'cell wall';
      } else if (v===FOREST) { cell.className = 'cell forest';
      } else { cell.className = 'cell path'; }

      // Spieler
      if (r===position.r && c===position.c){
        const s = document.createElement('div');
        if (playerImageURL){ s.className = 'sprite'; s.style.backgroundImage = `url('${playerImageURL}')`; }
        else { s.className = 'sprite emoji'; s.textContent = 'üéÖ'; }
        s.setAttribute('aria-hidden','true');
        cell.classList.add('player'); cell.tabIndex = 0; cell.appendChild(s);
      }

      // Taschenlampe/Fog
      if (!lampOn){
        if (!seenEver[r][c]) {
          if (v !== FOREST) cell.classList.add('fog'); // Forest bleibt sichtbar
        } else if (fringeNow[r][c]) {
          if (v===PATH || (r===goal.r && c===goal.c)){ cell.classList.add('dim'); }
        }
      }

      mazeEl.appendChild(cell);
    }
  }
  focusPlayer();
}

/* Sichtzust√§nde */
function computeVisibilityStates(){
  const seenEver = Array.from({length:GRID},()=>Array(GRID).fill(false));
  const fringeNow = Array.from({length:GRID},()=>Array(GRID).fill(false));

  if (lampOn){
    for (let r=0;r<GRID;r++) for (let c=0;c<GRID;c++) seenEver[r][c]=true;
    return { seenEver, fringeNow };
  }

  if (visited){
    for (const key of visited){
      const [r,c] = key.split(',').map(Number);
      if (r>=0 && c>=0 && r<GRID && c<GRID) seenEver[r][c]=true;
    }
  }

  const R = position.r, C = position.c;
  for (let r=R-FOG_RADIUS; r<=R+FOG_RADIUS; r++){
    for (let c=C-FOG_RADIUS; c<=C+FOG_RADIUS; c++){
      if (r>=0 && c>=0 && r<GRID && c<GRID){
        if (Math.max(Math.abs(r-R), Math.abs(c-C)) <= FOG_RADIUS){
          if (!visited.has(`${r},${c}`)) fringeNow[r][c] = true;
          seenEver[r][c] = true;
        }
      }
    }
  }
  return { seenEver, fringeNow };
}

function focusPlayer(){
  const p = mazeEl.querySelector('.player');
  if (p) p.focus({preventScroll:true});
}

/* Bewegung & Win */
function canMove(r,c){ return !(r<0||c<0||r>=GRID||c>=GRID) && grid[r][c]!==WALL; }
function move(dr,dc){
  const nr=position.r+dr, nc=position.c+dc;
  if(!canMove(nr,nc)) return;
  position={r:nr,c:nc};
  visited.add(`${nr},${nc}`);
  draw();
  if(position.r===goal.r && position.c===goal.c){
    document.getElementById('win').style.display='block';
    document.getElementById('letter').textContent='N';
    detachControls();
  }
}

/* Tastatur */
function keyHandler(e){
  const k=e.key.toLowerCase();
  if(['arrowup','w'].includes(k)) move(-1,0);
  else if(['arrowdown','s'].includes(k)) move(1,0);
  else if(['arrowleft','a'].includes(k)) move(0,-1);
  else if(['arrowright','d'].includes(k)) move(0,1);
}

/* Touch ‚Äì horizontale Wischgeste bewegt die Figur, vertikales Scrollen bleibt */
let sx=0, sy=0, st=0;
const SWIPE_MIN=22, SWIPE_MAXT=600;
function onTouchStart(e){
  if (!e.touches || e.touches.length!==1) return;
  sx=e.touches[0].clientX; sy=e.touches[0].clientY; st=Date.now();
}
function onTouchMove(e){ /* pan-y erlaubt */ }
function onTouchEnd(e){
  const dt=Date.now()-st; if(dt>SWIPE_MAXT) return;
  const t=e.changedTouches && e.changedTouches[0]; if(!t) return;
  const dx=t.clientX-sx, dy=t.clientY-sy;
  if (Math.max(Math.abs(dx),Math.abs(dy))<SWIPE_MIN) return;
  if (Math.abs(dx)>Math.abs(dy)){
    if (dx>0) move(0, 1); else move(0, -1);
    e.preventDefault(); // nur horizontales Wischen blockt Scrollen
  }
}

function attachControls(){
  detachControls();
  document.addEventListener('keydown', keyHandler);
  mazeEl.addEventListener('touchstart', onTouchStart, {passive:true});
  mazeEl.addEventListener('touchmove',  onTouchMove,  {passive:true});
  mazeEl.addEventListener('touchend',   onTouchEnd,   {passive:false});
  upBtn.onclick    = ()=>move(-1,0);
  downBtn.onclick  = ()=>move( 1,0);
  leftBtn.onclick  = ()=>move( 0,-1);
  rightBtn.onclick = ()=>move( 0, 1);
}
function detachControls(){
  document.removeEventListener('keydown', keyHandler);
  mazeEl.removeEventListener('touchstart', onTouchStart);
  mazeEl.removeEventListener('touchmove',  onTouchMove);
  mazeEl.removeEventListener('touchend',   onTouchEnd);
}
</script>
</body>
</html>










